<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@100&display=swap" rel="stylesheet">
		<style>
			@import url('https://fonts.googleapis.com/css2?family=Roboto+Mono&display=swap');
		</style>
		<title>Jake Mangino Portfolio</title>
		<style>
			body { margin: 0; }
		</style>
		

		<script type="module" crossorigin src="/assets/index-FNOAKWHt.js"></script>
		<link rel="stylesheet" crossorigin href="/assets/index-T4ZFvD9I.css">
	</head>
	<script src="rStats.js"></script>

	<body id="body">
		<!--
		<div class='row' id="row">
			<div class='column first-column-wrapper' id="first-column-wrapper">
				<div class='green-column' id="project-text">
					<h1 class="left"><i>BIRD CLASSIFIER</i></h1>
					<embed type='text/html' width='100%' height='100%' src='https://manginoja.github.io/455/'>
					<br>
					<br>
					<h1 class="right"><i>TEXT PREDICTION</i></h1>
					<p>Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.</p>
					<br>
					<br>
					<h1 class="left"><i>PORTFOLIO</i></h1> 
				</div>
			</div>
			<div class='column second-column-wrapper' id="second-column-wrapper">
				
			</div>
		</div>
	-->
	<script id="vertexShader" type="x-shader/x-vertex">

		#include <fog_pars_vertex>
  
		uniform float time;
		varying vec2 vUv;
  
		void main() {
  
			vUv = uv;
  
			vec3 transformed = vec3( position );

			#ifdef USE_ALPHAHASH

				vPosition = vec3( position );

			#endif

			vec4 mvPosition = vec4( transformed, 1.0 );
			if (mvPosition.y > 4.0) {
				mvPosition.z = .01 * (mvPosition.y + 2.0 * sin(time)) * sin((mvPosition.x + time / 1.5 )/ 0.2);
			}

			#ifdef USE_BATCHING

				mvPosition = batchingMatrix * mvPosition;

			#endif

			#ifdef USE_INSTANCING

				mvPosition = instanceMatrix * mvPosition;

			#endif

			mvPosition = modelViewMatrix * mvPosition;

			gl_Position = projectionMatrix * mvPosition;
			#include <fog_vertex>
  
		}
	  </script>
  
	  <script id="fragmentShader" type="x-shader/x-fragment">
  
		#include <common>
		#include <packing>
		#include <fog_pars_fragment>
  
		varying vec2 vUv;
		uniform sampler2D tDepth;
		uniform sampler2D tDudv;
		uniform vec3 waterColor;
		uniform vec3 foamColor;
		uniform float cameraNear;
		uniform float cameraFar;
		uniform float time;
		uniform float threshold;
		uniform vec2 resolution;
  
		float getDepth( const in vec2 screenPosition ) {
			#if DEPTH_PACKING == 1
				return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );
			#else
				return texture2D( tDepth, screenPosition ).x;
			#endif
		}
  
		float getViewZ( const in float depth ) {
			#if ORTHOGRAPHIC_CAMERA == 1
				return orthographicDepthToViewZ( depth, cameraNear, cameraFar );
			#else
				return perspectiveDepthToViewZ( depth, cameraNear, cameraFar );
			#endif
		}
  
		void main() {
  
			vec2 screenUV = gl_FragCoord.xy / resolution;

      	float fragmentLinearEyeDepth = getViewZ( gl_FragCoord.z );
      	float linearEyeDepth = getViewZ( getDepth( screenUV ) );

      	float diff = saturate( fragmentLinearEyeDepth - linearEyeDepth );

        float foamForce = 0.3;

        float thickness = 0.11;

      	float foamScale = 3.0;  // Adjust the foam scale value to control the fineness of the foam

        vec2 displacement = texture2D( tDudv, ( vUv * foamScale ) - time * 0.05 ).rg;
        displacement = ( ( displacement * 2.0 ) - 1.0 ) * 1.0;

        float waveAmount = sin((vUv.x + vUv.y) * 10.0 + time * 5.0) * foamForce;  // Adjust the parameters to control the wave effect
        displacement.x += waveAmount;
        displacement.y += waveAmount;

        diff += displacement.x;

      	gl_FragColor.rgb = mix( foamColor, waterColor, step( threshold / (0.1 / thickness), diff ) );
      	gl_FragColor.a = 1.0;
  
			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>
  
		}
	  </script>
	  <script id="toonVertexShader" type="x-shader/x-vertex">
		#include <common>
		#include <shadowmap_pars_vertex>

		uniform float uGlossiness;
		varying vec3 vNormal;
		varying vec3 vViewDir;
		varying vec3 vPosition;

		void main() {
			#include <beginnormal_vertex>
			#include <defaultnormal_vertex>
		
			#include <begin_vertex>
		
			#include <worldpos_vertex>
			#include <shadowmap_vertex>
			
			
			vec4 modelPosition = modelMatrix * vec4(position, 1.0);
  			vec4 viewPosition = viewMatrix * modelPosition;
  			vec4 clipPosition = projectionMatrix * viewPosition;

			vNormal = normalize(normalMatrix * normal);
			vPosition = viewPosition.xyz;

			if (uGlossiness > 0.0) {
				vViewDir = normalize(-viewPosition.xyz);
			}

  			gl_Position = clipPosition;
		}
		
	  </script>
  
	  <script id="toonFragmentShader" type="x-shader/x-fragment">
		#include <common>
		#include <packing>
		#include <lights_pars_begin>
		#include <shadowmap_pars_fragment>
		#include <shadowmask_pars_fragment>

		uniform vec3 uColor;
		uniform float uGlossiness;

		varying vec3 vNormal;
		varying vec3 vViewDir;
		varying vec3 vPosition;

		float getLightIntensity(const in float dotProduct, const in float shadow) {
			float lightIntensity;
			if (dotProduct < .25) {
				lightIntensity = smoothstep(0.0, .01, dotProduct * shadow) * 0.25;
			} else if (dotProduct < .5) {
				lightIntensity = smoothstep(0.0, .01, dotProduct * shadow) * .5;
			} else if (dotProduct < .75) {
				lightIntensity = smoothstep(0.0, .01, dotProduct * shadow) * .75;
			} else {
				lightIntensity = smoothstep(0.0, .01, dotProduct * shadow);
			}
			return lightIntensity;
		}

		void main() {
			

			// shadow map
			DirectionalLightShadow directionalShadow = directionalLightShadows[0];

			float shadow = getShadow(
				directionalShadowMap[0],
				directionalShadow.shadowMapSize,
				directionalShadow.shadowBias,
				directionalShadow.shadowRadius,
				vDirectionalShadowCoord[0]
			);

			// light intensity
			float NdotL = dot(vNormal, directionalLights[0].direction);
			float directionalLightIntensity = getLightIntensity(NdotL, shadow);
			vec3 directionalLight = directionalLights[0].color * directionalLightIntensity;


			vec3 pointLightCombined = vec3(1.0, 1.0, 1.0);

			if (pointLights[0].color.x > 0.0) {
				float NdotPL0 = dot(vNormal, normalize(pointLights[0].position - vPosition));
				float NdotPL1 = dot(vNormal, normalize(pointLights[1].position - vPosition));
				float pointLight0Intensity = getLightIntensity(NdotPL0, 1.0);
				float pointLight1Intensity = getLightIntensity(NdotPL1, 1.0);
				vec3 pointLight0Color = pointLights[0].color;
				pointLight0Color *= getDistanceAttenuation( length(pointLights[0].position - vPosition), pointLights[0].distance, pointLights[0].decay );
				vec3 pointLight1Color = pointLights[1].color;
				pointLight1Color *= getDistanceAttenuation( length(pointLights[1].position - vPosition), pointLights[1].distance, pointLights[1].decay );
				pointLightCombined = (pointLight0Color * pointLight0Intensity) + (pointLight1Color * pointLight1Intensity);
			}
			

			// specular reflection
			vec3 specular = vec3(0.0, 0.0, 0.0);
			if (uGlossiness > 0.0) {
				vec3 halfVector = normalize(directionalLights[0].direction + vViewDir);
				float NdotH = dot(vNormal, halfVector);
				
				float overallLightIntensity = smoothstep(0.0, .01, NdotL * shadow);
				float specularIntensity = pow(NdotH * overallLightIntensity, 1000.0 / uGlossiness);
				float specularIntensitySmooth = smoothstep(0.05, 0.1, specularIntensity);
			
				specular = specularIntensitySmooth * directionalLights[0].color;
			}

			if (pointLightCombined.x <= 0.1) {
				pointLightCombined = vec3(1.0, 1.0, 1.0);
			}
			if (directionalLightIntensity < 0.50 ) {
				gl_FragColor = vec4(0.1 * directionalLights[0].color * uColor * ambientLightColor * pointLightCombined, 1.0 );
			} else {
				gl_FragColor = vec4(directionalLight * uColor * ambientLightColor * pointLightCombined + specular, 1.0 );
			}
  
			#include <colorspace_fragment>
		}
		
	  </script>
		
		<div id="titleContainer">
			<p id="title"><b>jake mangino</b></p>
			
		</div>
		<div id="menuContainer">
			<p class="buttons" id="about">about</p>
			<p class="buttons" id="projects">projects</p>
		</div>
	</body>
</html>
